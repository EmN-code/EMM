{
    "error": [],
    "errorstate": "pass",
    "messages": [
        [
            "user",
            "I need to develop a Zephyr program for the ESP32 that connects to a UDP server at `47.102.103.1:20001` to send device state (\u201dwork or not work\u201d) by UDP method every five seconds."
        ],
        [
            "assistant",
            "prefix: This Zephyr program for the ESP32 creates a UDP client that repeatedly sends a message indicating the device state (\"work or not work\") to a specified UDP server every five seconds. The server IP address is set to `47.102.103.1` and the port is `20001`. The code includes necessary Zephyr headers for networking and kernel operations. A UDP socket is created and used in a loop to send the message to the server address. Between each message send operation, the program waits for 5000 milliseconds, effectively making the device send the state every five seconds. \n block: #include <zephyr/sys/iterable_sections.h>\n#include <zephyr/net/net_ip.h>\n#include <zephyr/net/socket.h>\n#include <zephyr/kernel.h>\n\n#define SERVER_ADDR \"47.102.103.1\"\n#define SERVER_PORT 20001\n#define SLEEP_TIME_MS 5000\n\nvoid main(void) {\n    struct sockaddr_in server_addr;\n    int sock;\n    const char *device_state = \"work or not work\";\n\n    // Clear and configure server address structure\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(SERVER_PORT);\n    inet_pton(AF_INET, SERVER_ADDR, &server_addr.sin_addr);\n\n    // Create a UDP socket\n    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    if (sock < 0) {\n        printk(\"Failed to create socket\\n\");\n        return;\n    }\n\n    while (1) {\n        // Send device state to server\n        int sent_bytes = sendto(sock, device_state, strlen(device_state), 0,\n                                (struct sockaddr *)&server_addr, sizeof(server_addr));\n\n        if (sent_bytes < 0) {\n            printk(\"Failed to send message\\n\");\n        } else {\n            printk(\"Message sent: %s\\n\", device_state);\n        }\n\n        // Wait for 5 seconds\n        k_sleep(K_MSEC(SLEEP_TIME_MS));\n    }\n\n    // Close the socket\n    close(sock);\n} \n"
        ]
    ],
    "generation": "#include <zephyr/sys/iterable_sections.h>\n#include <zephyr/net/net_ip.h>\n#include <zephyr/net/socket.h>\n#include <zephyr/kernel.h>\n\n#define SERVER_ADDR \"47.102.103.1\"\n#define SERVER_PORT 20001\n#define SLEEP_TIME_MS 5000\n\nvoid main(void) {\n    struct sockaddr_in server_addr;\n    int sock;\n    const char *device_state = \"work or not work\";\n\n    // Clear and configure server address structure\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(SERVER_PORT);\n    inet_pton(AF_INET, SERVER_ADDR, &server_addr.sin_addr);\n\n    // Create a UDP socket\n    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n    if (sock < 0) {\n        printk(\"Failed to create socket\\n\");\n        return;\n    }\n\n    while (1) {\n        // Send device state to server\n        int sent_bytes = sendto(sock, device_state, strlen(device_state), 0,\n                                (struct sockaddr *)&server_addr, sizeof(server_addr));\n\n        if (sent_bytes < 0) {\n            printk(\"Failed to send message\\n\");\n        } else {\n            printk(\"Message sent: %s\\n\", device_state);\n        }\n\n        // Wait for 5 seconds\n        k_sleep(K_MSEC(SLEEP_TIME_MS));\n    }\n\n    // Close the socket\n    close(sock);\n}",
    "runtimelogs": "",
    "runtimestate": "",
    "iterations": 1
}