{
    "error": [],
    "errorstate": "pass",
    "messages": [
        [
            "user",
            "I need to develop a Zephyr program for the ESP32 that connects to an MQTT broker at 47.102.103.1:1883 to publish state (\u201dwork or not work\u201d) each five seconds. Do not use emcute lib."
        ],
        [
            "assistant",
            "prefix: To create a Zephyr program for the ESP32 that connects to an MQTT broker and publishes a state message every five seconds, we will use the native MQTT API instead of the `emcute` library. The steps involved are:\n1. Initialize the MQTT client and configure the connection parameters such as the broker address and port.\n2. Connect to the MQTT broker using the client's connect function.\n3. Set up a loop that publishes the state message (`\"work or not work\"`) to a predefined topic every five seconds.\n4. Ensure the program handles connection events, disconnection, and any publish errors.\n5. Include necessary headers in descending alphabetical order.\n6. Implement the main function to initialize the network and run the publish loop.\n\n**Header Files Order**: We ensure to include the necessary headers in descending alphabetical order, adhering to C/C++ standards.\n\n**MQTT Client Configuration**:\n- Broker IP: `47.102.103.1`\n- Port: `1883`\n\nThe following code implements these functionalities. \n block: #include <zephyr/net/mqtt.h>\n#include <zephyr/kernel.h>\n#include <zephyr/device.h>\n\n#define BROKER_ADDR  \"47.102.103.1\"\n#define BROKER_PORT  1883\n#define PUB_TOPIC    \"esp32/state\"\n#define PUB_MSG      \"work or not work\"\n#define PUB_INTERVAL K_SECONDS(5)\n\nstatic struct mqtt_client client;\nstatic struct sockaddr_in broker;\n\nvoid prepare_mqtt_client(void) {\n    mqtt_client_init(&client);\n    broker.sin_family = AF_INET;\n    broker.sin_port = htons(BROKER_PORT);\n    inet_pton(AF_INET, BROKER_ADDR, &broker.sin_addr);\n\n    client.broker = &broker;\n    client.evt_cb = NULL;\n}\n\nint publish_state(void) {\n    struct mqtt_publish_param param;\n\n    param.message.topic.qos = MQTT_QOS_0_AT_MOST_ONCE;\n    param.message.topic.topic.utf8 = PUB_TOPIC;\n    param.message.topic.topic.size = strlen(PUB_TOPIC);\n    param.message.payload.data = PUB_MSG;\n    param.message.payload.len = strlen(PUB_MSG);\n    param.dup_flag = 0;\n    param.retain_flag = 0;\n    \n    return mqtt_publish(&client, &param);\n}\n\nint main(void) {\n    int rc;\n    prepare_mqtt_client();\n\n    rc = mqtt_connect(&client);\n    if (rc != 0) {\n        printk(\"Failed to connect to MQTT broker: %d\\n\", rc);\n        return rc;\n    }\n\n    while (1) {\n        rc = publish_state();\n        if (rc != 0) {\n            printk(\"Failed to publish message: %d\\n\", rc);\n        }\n        k_sleep(PUB_INTERVAL);\n    }\n\n    return 0;\n} \n"
        ]
    ],
    "generation": "#include <zephyr/net/mqtt.h>\n#include <zephyr/kernel.h>\n#include <zephyr/device.h>\n\n#define BROKER_ADDR  \"47.102.103.1\"\n#define BROKER_PORT  1883\n#define PUB_TOPIC    \"esp32/state\"\n#define PUB_MSG      \"work or not work\"\n#define PUB_INTERVAL K_SECONDS(5)\n\nstatic struct mqtt_client client;\nstatic struct sockaddr_in broker;\n\nvoid prepare_mqtt_client(void) {\n    mqtt_client_init(&client);\n    broker.sin_family = AF_INET;\n    broker.sin_port = htons(BROKER_PORT);\n    inet_pton(AF_INET, BROKER_ADDR, &broker.sin_addr);\n\n    client.broker = &broker;\n    client.evt_cb = NULL;\n}\n\nint publish_state(void) {\n    struct mqtt_publish_param param;\n\n    param.message.topic.qos = MQTT_QOS_0_AT_MOST_ONCE;\n    param.message.topic.topic.utf8 = PUB_TOPIC;\n    param.message.topic.topic.size = strlen(PUB_TOPIC);\n    param.message.payload.data = PUB_MSG;\n    param.message.payload.len = strlen(PUB_MSG);\n    param.dup_flag = 0;\n    param.retain_flag = 0;\n    \n    return mqtt_publish(&client, &param);\n}\n\nint main(void) {\n    int rc;\n    prepare_mqtt_client();\n\n    rc = mqtt_connect(&client);\n    if (rc != 0) {\n        printk(\"Failed to connect to MQTT broker: %d\\n\", rc);\n        return rc;\n    }\n\n    while (1) {\n        rc = publish_state();\n        if (rc != 0) {\n            printk(\"Failed to publish message: %d\\n\", rc);\n        }\n        k_sleep(PUB_INTERVAL);\n    }\n\n    return 0;\n}",
    "runtimelogs": "",
    "runtimestate": "",
    "iterations": 1
}