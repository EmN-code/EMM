{
    "error": [],
    "errorstate": "pass",
    "messages": [
        [
            "user",
            "I need to develop a RIOT program for the ESP32 that connects to a UDP server at\u00a0`47.102.103.1:20001`\u00a0to send device state (\u201dwork or not work\u201d) by UDP method every five seconds."
        ],
        [
            "user",
            "#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <string.h>\n\n#define SERVER_PORT 8888\n#define BUFF_LEN 512\n#define SERVER_IP \"172.0.5.182\"\n\n\nvoid udp_msg_sender(int fd, struct sockaddr* dst)\n{\n\n    socklen_t len;\n    struct sockaddr_in src;\n    while(1)\n    {\n        char buf[BUFF_LEN] = \"TEST UDP MSG!\\n\";\n        len = sizeof(*dst);\n        printf(\"client:%s\\n\",buf);  //\u6253\u5370\u81ea\u5df1\u53d1\u9001\u7684\u4fe1\u606f\n        sendto(fd, buf, BUFF_LEN, 0, dst, len);\n        memset(buf, 0, BUFF_LEN);\n        recvfrom(fd, buf, BUFF_LEN, 0, (struct sockaddr*)&src, &len);  //\u63a5\u6536\u6765\u81easerver\u7684\u4fe1\u606f\n        printf(\"server:%s\\n\",buf);\n        sleep(1);  //\u4e00\u79d2\u53d1\u9001\u4e00\u6b21\u6d88\u606f\n    }\n}\n\n/*\n    client:\n            socket-->sendto-->revcfrom-->close\n*/\n\nint main(int argc, char* argv[])\n{\n    int client_fd;\n    struct sockaddr_in ser_addr;\n\n    client_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if(client_fd < 0)\n    {\n        printf(\"create socket fail!\\n\");\n        return -1;\n    }\n\n    memset(&ser_addr, 0, sizeof(ser_addr));\n    ser_addr.sin_family = AF_INET;\n    //ser_addr.sin_addr.s_addr = inet_addr(SERVER_IP);\n    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //\u6ce8\u610f\u7f51\u7edc\u5e8f\u8f6c\u6362\n    ser_addr.sin_port = htons(SERVER_PORT);  //\u6ce8\u610f\u7f51\u7edc\u5e8f\u8f6c\u6362\n\n    udp_msg_sender(client_fd, (struct sockaddr*)&ser_addr);\n\n    close(client_fd);\n\n    return 0;\n}\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <string.h>\n\n#define SERVER_PORT 8888\n#define BUFF_LEN 1024\n\nvoid handle_udp_msg(int fd)\n{\n    char buf[BUFF_LEN];  //\u63a5\u6536\u7f13\u51b2\u533a\uff0c1024\u5b57\u8282\n    socklen_t len;\n    int count;\n    struct sockaddr_in clent_addr;  //clent_addr\u7528\u4e8e\u8bb0\u5f55\u53d1\u9001\u65b9\u7684\u5730\u5740\u4fe1\u606f\n    while(1)\n    {\n        memset(buf, 0, BUFF_LEN);\n        len = sizeof(clent_addr);\n        count = recvfrom(fd, buf, BUFF_LEN, 0, (struct sockaddr*)&clent_addr, &len);  //recvfrom\u662f\u62e5\u585e\u51fd\u6570\uff0c\u6ca1\u6709\u6570\u636e\u5c31\u4e00\u76f4\u62e5\u585e\n        if(count == -1)\n        {\n            printf(\"recieve data fail!\\n\");\n            return;\n        }\n        printf(\"client:%s\\n\",buf);  //\u6253\u5370client\u53d1\u8fc7\u6765\u7684\u4fe1\u606f\n        memset(buf, 0, BUFF_LEN);\n        sprintf(buf, \"I have recieved %d bytes data!\\n\", count);  //\u56de\u590dclient\n        printf(\"server:%s\\n\",buf);  //\u6253\u5370\u81ea\u5df1\u53d1\u9001\u7684\u4fe1\u606f\u7ed9\n        sendto(fd, buf, BUFF_LEN, 0, (struct sockaddr*)&clent_addr, len);  //\u53d1\u9001\u4fe1\u606f\u7ed9client\uff0c\u6ce8\u610f\u4f7f\u7528\u4e86clent_addr\u7ed3\u6784\u4f53\u6307\u9488\n\n    }\n}\n\n\n/*\n    server:\n            socket-->bind-->recvfrom-->sendto-->close\n*/\n\nint main(int argc, char* argv[])\n{\n    int server_fd, ret;\n    struct sockaddr_in ser_addr;\n\n    server_fd = socket(AF_INET, SOCK_DGRAM, 0); //AF_INET:IPV4;SOCK_DGRAM:UDP\n    if(server_fd < 0)\n    {\n        printf(\"create socket fail!\\n\");\n        return -1;\n    }\n\n    memset(&ser_addr, 0, sizeof(ser_addr));\n    ser_addr.sin_family = AF_INET;\n    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); //IP\u5730\u5740\uff0c\u9700\u8981\u8fdb\u884c\u7f51\u7edc\u5e8f\u8f6c\u6362\uff0cINADDR_ANY\uff1a\u672c\u5730\u5730\u5740\n    ser_addr.sin_port = htons(SERVER_PORT);  //\u7aef\u53e3\u53f7\uff0c\u9700\u8981\u7f51\u7edc\u5e8f\u8f6c\u6362\n\n    ret = bind(server_fd, (struct sockaddr*)&ser_addr, sizeof(ser_addr));\n    if(ret < 0)\n    {\n        printf(\"socket bind fail!\\n\");\n        return -1;\n    }\n\n    handle_udp_msg(server_fd);   //\u5904\u7406\u63a5\u6536\u5230\u7684\u6570\u636e\n\n    close(server_fd);\n    return 0;\n}"
        ]
    ],
    "generation": "\n#include <stdio.h>\n#include <string.h>\n#include \"net/sock/udp.h\"\n#include \"xtimer.h\"\n\n#define SERVER_IP \"47.102.103.1\"\n#define SERVER_PORT 20001\n#define BUFF_LEN 512\n#define DELAY_MS 5000000  // 5 seconds in microseconds\n\nvoid udp_msg_sender(sock_udp_ep_t *remote)\n{\n    sock_udp_t sock;\n    char buf[BUFF_LEN];\n    int res;\n\n    // Initialize the UDP socket\n    if (sock_udp_create(&sock, NULL, remote, 0) < 0) {\n        puts(\"Error creating UDP socket\");\n        return;\n    }\n\n    while (1) {\n        // Prepare the message\n        strcpy(buf, \"work\");  // Assuming \"work\" means the device is working\n        printf(\"Sending: %s\\n\", buf);\n\n        // Send the message\n        res = sock_udp_send(&sock, buf, strlen(buf), remote);\n        if (res < 0) {\n            puts(\"Error sending UDP message\");\n        }\n\n        // Wait for 5 seconds\n        xtimer_usleep(DELAY_MS);\n    }\n\n    // Close the socket\n    sock_udp_close(&sock);\n}\n\nint main(void)\n{\n    sock_udp_ep_t remote = SOCK_IPV4_EP_ANY;\n\n    // Set up the remote endpoint\n    remote.port = SERVER_PORT;\n    remote.family = AF_INET;\n    inet_pton(AF_INET, SERVER_IP, &remote.addr.ipv4.u32);\n\n    // Start sending messages\n    udp_msg_sender(&remote);\n\n    return 0;\n}\n",
    "runtimelogs": "",
    "runtimestate": "",
    "iterations": 1
}